#include <Windows.h>
#include <handleapi.h>
#include <iostream>
#include <fileapi.h>
#include <vector>
#include <string>
#include <fstream>
#include <filesystem>
#include <map>
#include <iomanip>
#include <sstream>

using namespace std;

class MalwareFamilyData {
public:

    string fileName;
    string filePath;
    string malwareType;
    string MD5_HASH;
    string SHA256_HASH;

    int numOfImports, numofExportsDlls;
    DWORD sizeOfImage;
    vector<string> malware_imports;
    vector<string> cleanedImports;

    std::map<string, vector<string>> allCommonImports = {
        {"KERNEL32.dll", {"CreateProcessA", "VirtualAlloc", "WriteProcessMemory", "GetModuleHandleA", "GetProcAddress", "LoadLibraryA", "Sleep", "CreateFileA", "ReadFile", "WriteFile", "DeleteFileA", "FindFirstFileA", "FindNextFileA", "CreateProcessA", "OpenProcess", "TerminateProcess", "GetSystemInfo", "IsDebuggerPresent"}},
        {"USER32.dll", {"MessageBoxA", "FindWindowA", "SetWindowTextA", "GetWindowTextA", "ShowWindow", "GetForegroundWindow", "CreateWindowExA", "SendMessageA", "SetWindowLongA"}},
        {"ADVAPI32.dll", {"RegOpenKeyA", "RegCloseKey", "RegDeleteKeyA", "RegOpenKeyExA", "RegSetValueExA", "RegCreateKeyExA", "RegQueryValueExA", "OpenProcessToken", "LookupPrivilegeValueA", "AdjustTokenPrivileges", "RegCreateKeyExA", "RegOpenKeyExA", "RegSetValueExA", "RegQueryValueExA"}},
        {"WS2_32.dll", {"WSAStartup", "socket", "connect", "send", "recv", "closesocket", "WSACleanup", "WSAStartup", "socket", "connect", "send", "recv", "HttpOpenRequestA"}},
        {"WININET.dll", {"InternetOpenA", "InternetConnectA", "HttpOpenRequestA", "HttpSendRequestA", "InternetReadFile", "InternetCloseHandle"}},
        {"URLMON.dll", {"URLDownloadToFileA"}},
        {"CRYPT32.dll", {"CryptAcquireContext", "CryptCreateHash", "CryptEncrypt"}}
    };

    MalwareFamilyData(string malwareName, string filePathName, string malwareFamily) {
        filePath = filePathName;
        fileName = malwareName;
        malwareType = malwareFamily;
    }

    ~MalwareFamilyData() {}

    
    void calculateMD5Hash() {
        std::ifstream file(filePath, std::ios::binary);
        if (!file.is_open()) {
            cerr << "File does not exist: " << filePath << endl;
            return;
        }

        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;

        if (!CryptAcquireContext(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
            cerr << "CryptAcquireContext error" << endl;
            file.close();
            return;
        }

        if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash)) {
            cerr << "CryptCreateHash error" << endl;
            CryptReleaseContext(hProv, 0);
            file.close();
            return;
        }

        constexpr size_t bufferSize = 4096;
        char buffer[bufferSize];
        while (file.read(buffer, bufferSize)) {
            if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(buffer), static_cast<DWORD>(file.gcount()), 0)) {
                cerr << "CryptHashData error" << endl;
                CryptReleaseContext(hProv, 0);
                CryptDestroyHash(hHash);
                file.close();
                return;
            }
        }

        file.close();

        BYTE hash[16];
        DWORD hashSize = sizeof(hash);

        if (!CryptGetHashParam(hHash, HP_HASHVAL, hash, &hashSize, 0)) {
            cerr << "CryptGetHashParam error" << endl;
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);
            return;
        }

        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);

        std::stringstream ss;
        for (DWORD i = 0; i < hashSize; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
        }
        MD5_HASH = ss.str();
    }

    DWORD GetModuleSize(HMODULE hModule) {
        PIMAGE_DOS_HEADER pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
        PIMAGE_NT_HEADERS pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<BYTE*>(hModule) + pDosHeader->e_lfanew);
        return pNtHeaders->OptionalHeader.SizeOfImage;
    }
    
    bool dumpImports() {
        HMODULE hModule = LoadLibraryEx(filePath.c_str(), nullptr, DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == nullptr) {
            cerr << "LoadLibraryEx failed: " << GetLastError() << endl;
            return false;
        }

        DWORD imageSize = GetModuleSize(hModule);

        sizeOfImage = imageSize;

        if (imageSize == 0) {
            cerr << "GetModuleSize failed" << endl;
            FreeLibrary(hModule);
            return false;
        }

        BYTE* pImageBase = new BYTE[imageSize];
        if (!ReadProcessMemory(GetCurrentProcess(), hModule, pImageBase, imageSize, nullptr)) {
            cerr << "ReadProcessMemory failed: " << GetLastError() << endl;
            delete[] pImageBase;
            FreeLibrary(hModule);
            return false;
        }

        PIMAGE_DOS_HEADER pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(pImageBase);
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            cerr << "Invalid DOS header" << endl;
            delete[] pImageBase;
            FreeLibrary(hModule);
            return false;
        }

        PIMAGE_NT_HEADERS pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(pImageBase + pDosHeader->e_lfanew);
        if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
            cerr << "Invalid NT signature" << endl;
            delete[] pImageBase;
            FreeLibrary(hModule);
            return false;
        }

        PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(
            pImageBase + pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

        if (pImportDescriptor == nullptr) {
            cerr << "No import table found" << endl;
            delete[] pImageBase;
            FreeLibrary(hModule);
            return false;
        }

        int numDlls = 0;
        int numImports = 0;

        while (pImportDescriptor->Name != 0) {
            string dllName = reinterpret_cast<char*>(pImageBase + pImportDescriptor->Name);

            ++numDlls; // Count all DLLs encountered

            PIMAGE_THUNK_DATA pOriginalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA>(
                pImageBase + pImportDescriptor->OriginalFirstThunk);
            PIMAGE_THUNK_DATA pFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA>(pImageBase + pImportDescriptor->FirstThunk);

            while (pOriginalFirstThunk->u1.AddressOfData != 0) {
                ++numImports; // Count all import functions

                PIMAGE_IMPORT_BY_NAME pImportByName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
                    pImageBase + pOriginalFirstThunk->u1.AddressOfData);

                string functionName = reinterpret_cast<char*>(pImportByName->Name);
                if (allCommonImports.find(dllName) != allCommonImports.end()) {
                    vector<string> commonFunctions = allCommonImports[dllName];
                    if (find(commonFunctions.begin(), commonFunctions.end(), functionName) != commonFunctions.end()) {
                        malware_imports.push_back("DLL: " + dllName + "\t" + functionName); // Store only important imports
                    }
                }

                ++pOriginalFirstThunk;
                ++pFirstThunk;
            }

            ++pImportDescriptor;
        }

        numofExportsDlls = numDlls; // Set the count of imported DLLs
        numOfImports = numImports; // Set the count of import functions

        delete[] pImageBase;
        FreeLibrary(hModule);

        return true;
    }


  


    void calculateSHA256() 
    {
        std::ifstream file(filePath, std::ios::binary);
        if (!file.is_open()) {
            cerr << "%s does not exist! include <.exe, or .dll!>" << endl;
        }

        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;

        if (!CryptAcquireContext(&hProv, nullptr, nullptr, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
            cerr << "crypt err" << endl;
        }

        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
            CryptReleaseContext(hProv, 0);
        }

        constexpr size_t bufferSize = 4096;
        char buffer[bufferSize];
        while (file.read(buffer, bufferSize)) {
            if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(buffer), static_cast<DWORD>(file.gcount()), 0)) {
                CryptReleaseContext(hProv, 0);
                CryptDestroyHash(hHash);
            }
        }

        file.close();

        BYTE hash[32];
        DWORD hashSize = sizeof(hash);

        if (!CryptGetHashParam(hHash, HP_HASHVAL, hash, &hashSize, 0)) {
            CryptReleaseContext(hProv, 0);
            CryptDestroyHash(hHash);
        }

        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);

        std::stringstream ss;
        for (DWORD i = 0; i < hashSize; ++i) {
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
        }
        SHA256_HASH = ss.str();

    }


    


};